mod imp;

use crate::drawing_area_manager::DrawingAreaManager;
use crate::edge::GrayEdge;
use rustshot_gtk::constants::CSS_FILE_PATH;
use std::io::Write;
// use crate::handles::Handles;
use crate::drawing_area_settings::SettingsRc;
use crate::screenshot_box::ScreenshotBox;
use crate::settings_window::SettingsWindow;
use crate::toolbox::Toolbox;

use gtk::{gdk, gio, glib, prelude::*, subclass::prelude::*};
use rustshot_gtk::constants::CSS_CLASS_TRANSPARENT;

glib::wrapper! {
    pub struct GeometryState(ObjectSubclass<imp::GeometryState>)
   @extends gtk::ApplicationWindow, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Default for GeometryState {
    fn default() -> Self {
        glib::Object::new()
    }
}

impl GeometryState {
    pub fn attach_gestures(&self) {
        // geometry
        let geom = self.imp();

        // Create toolbox buttons
        geom.toolbox.create_toolbox_buttons(&self);

        // Make screenshot box resizable
        geom.screenshot_box.attach_handles_gesture(&self);

        // layout
        let layout = geom.layout.clone();

        // drawing area
        let drawing = geom.drawing.clone();

        // toolbox
        let settings_window = geom.settings_window.clone();

        // ---------------------------------------
        // Install drag gesture for the screenshot creation
        // ---------------------------------------
        let gest = gtk::GestureDrag::new();
        layout.add_controller(gest.clone());

        gest.connect_drag_begin(glib::clone!(move |_, x, y| {
            self.drag_begin(x, y);
        }));

        gest.connect_drag_update(glib::clone!(move |_, x, y| {
            self.drag_update(x, y);
        }));

        gest.connect_drag_end(glib::clone!(move |gest, x, y| {
            self.drag_end(x, y);

            // detach gesture after initial setup
            layout.remove_controller(gest);

            // draw toolbox
            geom.toolbox.draw_toolbox(&self);
        }));

        // draw boxes on screenshot_box box
        let draw_gesture = gtk::GestureDrag::new();
        geom.screenshot_box.add_controller(draw_gesture.clone());

        // Clone the initial position
        let left = geom.left_box.clone();
        let top = geom.top_box.clone();

        // screenshot_box.add_controller(draw_box.clone());
        draw_gesture.connect_drag_begin(glib::clone!(
            #[strong]
            settings_window,
            #[weak]
            drawing,
            move |_, x, y| {
                if drawing.is_drawing() {
                    drawing
                        // 10 is handle size
                        .drag_begin(
                            left.get_edge_f64() + 10.0 + x,
                            top.get_edge_f64() + 10.0 + y,
                        );
                    drawing.queue_draw(); // Request a redraw
                    settings_window.set_visible(false);
                }
            }
        ));
        draw_gesture.connect_drag_update(glib::clone!(
            #[weak]
            drawing,
            move |_, x, y| {
                if drawing.is_drawing() {
                    drawing.drag_update(x, y);
                    drawing.queue_draw(); // Request a redraw
                }
            }
        ));
        draw_gesture.connect_drag_end(glib::clone!(move |_, _, _| {
            if drawing.is_drawing() {
                drawing.drag_end();
            }
        },));
    }

    pub fn set_new_geometry_f64(&self, top: f64, left: f64, bottom: f64, right: f64) {
        let imp = self.imp();
        imp.top_box.set_edge_f64(top);
        imp.left_box.set_edge_f64(left);
        imp.bottom_box.set_edge_f64(bottom);
        imp.right_box.set_edge_f64(right);
    }

    pub fn drag_begin(&self, x: f64, y: f64) {
        let imp = self.imp();

        // calculate
        let t: f64 = y;
        let l: f64 = x;
        let b: f64 = imp.full_h as f64 - t;
        let r: f64 = imp.full_w as f64 - l;

        // set new geometry
        self.set_new_geometry_f64(t, l, b, r);
    }

    /// Updates the rectangle defined by the four edge boxes when the user drags.
    pub fn drag_update(&self, x: f64, y: f64) {
        let imp = self.imp();
        let mut top = imp.top_box.get_edge_f64();
        let mut left = imp.left_box.get_edge_f64();
        let mut bottom = imp.bottom_box.get_edge_f64();
        let mut right = imp.right_box.get_edge_f64();

        if x.signum() < 0.0 {
            left += x;
        } else {
            right -= x;
        }

        if y.signum() < 0.0 {
            top += y;
        } else {
            bottom -= y;
        }

        if top < 0.0 || right < 0.0 || bottom < 0.0 || left < 0.0 {
            return;
        }

        // It is important not to update the top, left,... values BUT ONLY THE WIDGET!
        // otherwise the screenshot area moves inconsistently
        imp.top_box.set_edge_pending(top as i32);
        imp.left_box.set_edge_pending(left as i32);
        imp.bottom_box.set_edge_pending(bottom as i32);
        imp.right_box.set_edge_pending(right as i32);
    }

    pub fn drag_end(&self, _x: f64, _y: f64) {
        let imp = self.imp();
        // save
        imp.top_box.resolve_edge_pending();
        imp.left_box.resolve_edge_pending();
        imp.bottom_box.resolve_edge_pending();
        imp.right_box.resolve_edge_pending();

        // set screenshot box visible to true
        // it is useful because with Handles it will be continuously set visible/invisible
        imp.screenshot_box.set_visible(true);
    }

    pub fn get_screenshot_size(&self) -> [i32; 4] {
        let imp = self.imp();
        let x = imp.left_box.get_edge();
        let y = imp.top_box.get_edge();
        let w = imp.full_w - x - imp.right_box.get_edge();
        let h = imp.full_h - y - imp.bottom_box.get_edge();
        return [x, y, w, h];
    }

    pub fn take_screenshot(&self) {
        let dim = self.get_screenshot_size();
        let x = dim[0];
        let y = dim[1];
        let w = dim[2];
        let h = dim[3];

        // build the grim string like "10,20 400x900"
        // we need to subtract the border of the screenbox (which is 2px, see style.css)
        let grim_string = &format!("{},{} {}x{}", x + 1, y + 1, w, h);

        // Execute the `grim` command
        let grim_output = std::process::Command::new("grim")
            .arg("-g")
            .arg(grim_string)
            .arg("-")
            .stdout(std::process::Stdio::piped()) // Capture the output
            .output() // Execute the command
            .expect("Failed to execute grim");

        // Check if the grim command was successful
        if grim_output.status.success() {
            // Write the output of grim to wl-copy's stdin
            let mut wl_copy_process = std::process::Command::new("wl-copy")
                .stdin(std::process::Stdio::piped()) // Use a pipe for stdin
                .spawn() // Start the wl-copy process
                .expect("Failed to start wl-copy");

            // Write the grim output to wl-copy's stdin
            if let Some(stdin) = wl_copy_process.stdin.as_mut() {
                stdin
                    .write_all(&grim_output.stdout)
                    .expect("Failed to write to wl-copy");
            }

            // Wait for wl-copy to finish
            let _ = wl_copy_process
                .wait()
                .expect("wl-copy did not run successfully");

            println!("Screenshot (region: {}) copied to clipboard.", grim_string);
        } else {
            // Handle the error case for grim
            let stderr = String::from_utf8_lossy(&grim_output.stderr);
            eprintln!("Error executing grim: {}", stderr);
        }
    }

    pub fn save_screenshot(&self, file: gio::File) {
        let dim = self.get_screenshot_size();
        let x = dim[0];
        let y = dim[1];
        let w = dim[2];
        let h = dim[3];

        // get filename
        let filename = file.path().expect("Couldn't get file path");

        // build the grim string like "10,20 400x900"
        // we need to subtract the border of the screenbox (which is 2px, see style.css)
        let grim_string = &format!("{},{} {}x{}", x + 1, y + 1, w, h);

        // Execute the `grim` command
        let _grim_output = std::process::Command::new("grim")
            .arg("-g")
            .arg(grim_string)
            .arg(filename)
            .output() // Execute the command
            .expect("Failed to execute grim");
    }

    fn get_monitor_size() -> (i32, i32) {
        let mut max_w: i32 = 0_i32;
        let mut max_h: i32 = 0_i32;

        // manage multiple monitors
        let screen = gdk::Display::default().expect("No gtk::Display detected!");
        let monitors = screen.monitors();
        let n_monitors = monitors.n_items();

        // get the screens sizes
        for monitor_n in 0..n_monitors {
            let obj = monitors.item(monitor_n).unwrap();
            let primary_monitor = obj.downcast_ref::<gdk::Monitor>().unwrap();
            let geometry = primary_monitor.geometry();

            // fill vectors
            let w: i32 = geometry.x() + geometry.width();
            let h: i32 = geometry.y() + geometry.height();

            // Find maximum
            if w > max_w {
                max_w = w;
            }
            if h > max_h {
                max_h = h;
            }
        }

        (max_w, max_h)
    }

    fn set_css() {
        // set provider style.css
        let provider = gtk::CssProvider::new();
        provider.load_from_string(CSS_FILE_PATH);
        gtk::style_context_add_provider_for_display(
            &gdk::Display::default().expect("Could not connect to a display."),
            &provider,
            gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
        );
    }
}
